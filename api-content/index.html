{"posts":[{"title":"「回中网安」3：密码学——古典密码学","content":"密码学-古典密码学 古典密码学分为替代和置换两大类 键盘密码 运用键盘的布局等进行加密，位移等 布局形状 Tips：看键盘！ tgvhn uygbnjm uygbn yhnijm flag：hack 坐标加密 35 16 13 flag：bye 这个我个人觉得脑洞有点大，基本不会出现，所以只展示两个给大家看看 凯撒密码 这是一种简单的位移密码，最标准的凯撒密码是位移3位 示例密文：eucmugcgu flag：kaisamima 只需要理解原理，可以使用解密工具进行解密即可 使用夺旗工具里面的CTF Crack！ ROT13密码——凯撒密码的变体 和凯撒密码一样进行位移，但是一定是十三位 示例密文：URYYB flag：HELLO 只需要理解原理，可以使用解密工具进行解密即可 使用夺旗工具里面的CTF Crack！ 还有其他变体可能使用ASCII码进行变换迭代 频率密码 频率密码是根据单个字母出现的频率，对密码进行替换加密的方法 研究字母或者字母组合在文本中出现的频率。无论在何种自然语言体系当中，不同的文字单位都有其特定的出现频率，这个特征一般表现在长篇幅、有意义的文字序列中。以英文为例，出现频率最高的字母是e，其次是t、a、o….. 示例密文： Lw! Gyzvecy ke WvyVKT! W'zz by reso dsbdkwksky tzjq teo kly ujr. Teo keujr, gy joy dksurwmq bjdwv vorakeqojalr jmu wkd jaazwvjkwemd. Vorakeqojalr ljd j zemq lwdkeor, jzklesql gwkl kly juxymk et vecaskyod wk ljd qekkym oyjzzr vecazwvjkyu. Decy dwcazy ezu vwalyod joy kly Vjydjo vwalyo, kly Xwqymyoy vwalyo, kly dsbdkwkskwem vwalyo, glwvl wd klwd emy, jmu de em. Jzcedk jzz et klydy vwalyod joy yjdwzr boeiym keujr gwkl kly lyza et vecaskyod. Decy myg ymvorakwem cykleud joy JYD, kly vsooymk dkjmujou teo ymvorakwem, jzemq gwkl ODJ. Vorakeqojalr wd j xjdk twyzu jmu wd xyor wmkyoydkwmq klesql. De iwvi bjvi, oyju sa em decy veez vwalyod jmu ljxy tsm! El jmu teo reso oyveoud cr mjcy wd WvyVKT{jzgjrd_zwdkym_ke_reso_dsbdkwksky_tzjqd}. 实用工具：https://www.quipqiup.com/ flag：IceCTF{always_listen_to_your_substitute_flags} 摩斯电码 这是一种替换密码，看到题目后会辨认，然后知道如何解密即可 解密可以使用夺旗工具里面的CTF Crack！ 示例密文：-- --- ... .. -.. .. .- -. -- .- flag：mosidianma BrainF**k和Ook密码 主要是对程序源代码进行加密，把一些指令替换为其他符号 BrainF**k +++++ +++[- &gt;++++ ++++&lt; ]&gt;+++ +++++ .++++ +.--- -.&lt;++ +[-&gt;+ ++&lt;]&gt; +.--- ----. &lt; Ook示例 Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Short Ook ..... ..... ..... .!?!! .?... ..... ..... ...?. ?!.?. ..... ..... ..... !.... ..... ..!.! !!!!! !!!.? ..... ..!?! !.?.. ....? .?!.? ..!.! !!!!! !!!!! !!!!. ?. flag：HMISL 只需要知道这两个加密方式长什么样就行啦！然后使用解密工具即可 例如使用工具：https://ctf.bugku.com/tool/brainfuck 培根密码 一种简单的替换密码，密文只有两个字母组成，由五个字母来表达一个字母 例如h被替换为aabbb，因此，看到只有两个字母组成的密文，那么大概率是培根密码 示例密文：aabbbaabaaababbababbabbbaaaaaababbaaaaaa flag：helloawa 常规培根密码表：i和j、u和v对应密文相同 扩展培根密码表：包括了26个字母 扩展使用 那么既然我们可以把任意字符串转化为ab两种形式，那么我们也可以用ab来表示大写小写等 比如说iloveuctfailoveuctfailoveuctfailoveuctfa 通过a表示大写，b表示小写的加密，例如aabbbaabaaababbababbabbbaaaaaababbaaaaaa 就可以变化为ILoveUCtFAIlOveUcTfaIlovEUCTFAiLovEUCTFA 那么用这段东西来表示培根密码的ab 这是一段示例的加密程序 package main import ( &quot;fmt&quot; &quot;strings&quot; ) func main() { pattern := &quot;aabbbaabaaababbababbabbbaaaaaababbaaaaaa&quot; text := &quot;iloveuctfailoveuctfailoveuctfailoveuctfa&quot; var result strings.Builder for i, char := range text { if pattern[i] == 'a' { result.WriteRune(rune(strings.ToUpper(string(char))[0])) } else if pattern[i] == 'b' { result.WriteRune(rune(strings.ToLower(string(char))[0])) } } fmt.Println(result.String()) } 推荐解密网站：https://rumkin.com/tools/cipher/baconian/ 也可以使用本地解密工具 仿射密码 仿射密码为单表加密的一种，字母系统中所有字母都藉一简单数学方程加密，对应至数值，或转回字母。它是一种替换密码，利用加密函数一个字母对一个字母的加密 加密函数是 E(x)= (ax + b) (mod m)，其中，a和m互质，m是字符集的大小。 （例如，26即是以26个字母作为编码，当m是26时，a必须是1，3，5，7，9，11，15，17，19，21，23，25其中之一） 对应密码表： 例题 假设密钥K= (7,3) 使用仿射密码体制加密单词hot并对得到的密文进行解密。 加密 加密函数： E(x)= (7x + 3) (mod 26) 根据上面英文字母编码表得到X 解密 求乘法逆元的方法 def extended_gcd(a, b): &quot;&quot;&quot; 扩展欧几里得算法 返回整数 x 和 y，使得 ax + by = gcd(a, b) &quot;&quot;&quot; if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y def mod_inverse(a, m): &quot;&quot;&quot; 计算 a 在模 m 下的乘法逆元 &quot;&quot;&quot; gcd, x, _ = extended_gcd(a, m) if gcd != 1: raise ValueError(f&quot;{a} 和 {m} 不是互质，逆元不存在。&quot;) else: return x % m # 示例 a = 7 m = 26 inverse = mod_inverse(a, m) print(f&quot;{a} 在模 {m} 下的乘法逆元是: {inverse}&quot;) 解密函数 求得a的乘法逆元为15 D(x) = 15(x - 3) (mod 26) def extended_gcd(a, b): &quot;&quot;&quot; 扩展欧几里得算法 返回整数 x 和 y，使得 ax + by = gcd(a, b) &quot;&quot;&quot; if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y def mod_inverse(a, m): &quot;&quot;&quot; 计算 a 在模 m 下的乘法逆元 &quot;&quot;&quot; gcd, x, _ = extended_gcd(a, m) if gcd != 1: raise ValueError(f&quot;{a} 和 {m} 不是互质，逆元不存在。&quot;) else: return x % m def affine_decrypt(ciphertext, a, b, m): &quot;&quot;&quot; 解密仿射密码 &quot;&quot;&quot; # 求乘法逆元 inv_a = mod_inverse(a, m) plaintext = &quot;&quot; for char in ciphertext: if char.isalpha(): y = ord(char) - ord('A') x = inv_a * (y - b) % m plaintext += chr(x + ord('A')) else: plaintext += char return plaintext # 示例 a = 7 b = 3 m = 26 ciphertext = &quot;axg&quot;.upper() plaintext = affine_decrypt(ciphertext, a, b, m) print(&quot;解密后文本:&quot;, plaintext) 加解密工具：http://www.hiencode.com/affine.html 猪圈密码 替换式密码，非常简单 各种密码变通：https://blog.csdn.net/weixin_47869330/article/details/111396033 维吉尼亚密码 明文：I love you 密钥：abc 密文：I mqvf aov 注意：重复使用密钥进行加密，推荐解密工具：https://www.qqxiuzi.cn/bianma/weijiniyamima.php 栅栏密码 栅栏密码（Rail Fence Cipher）是一种置换密码，它将明文按照一定规则写入多个栅栏中，然后将栅栏中的字符逐行读取以加密消息。例如，使用3个栅栏（3行）的栅栏密码将明文Welcome to HMISL!!写成如下形式： 1 2 3 4 5 6 1 W c e H S ! 2 e o t M L 3 l m o I ! 得到密文：WooSecmtHIL!leM! 在线工具：https://ctf.bugku.com/tool/railfence 费纳姆密码 二战德军使用的密码，属于二进制运算密码 明文： HELLO=1001000 1000101 1001100 1001100 1001111 密钥： CRUDE=1000011 1010010 1010101 1000100 1000101 异或运算： 密文：0001011 0010111 0011001 0001000 0001010 解算脚本，顺便了解GitHub的使用：https://github.com/0neOfU4/fenhum-decode 杰斐逊转轮加密 杰斐逊转轮加密器，这个装置由36片同样大小的木制转轮，套在一根杆上。每片转轮的圆周边缘上可有乱序的26个英文字母表 通信双方必须各自拥有一套完全一样的转轮加密器。 加密方转动加密器上的转轮，是明文（不超过36字）正好出现在同一行上，这时转轮排列的其他25行都是无意义的乱码，把其中任意一行的乱码抄写来，得到密文。 接收方收到密文，转动加密器上的转轮，使得密文正好出现在同一行上，然后查看其他25行的内容，有意义的行就是明文。 杰斐逊加密器属于典型的“多表替换”加密（每一个转轮就相当于一个替换的字母表），他很难破解，除非能得到通信双方所使用的加密装置。 加密示例： 1： &lt;ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt; 2： &lt;KPBELNACZDTRXMJQOYHGVSFUWI &lt; 3： &lt;BDMAIZVRNSJUWFHTEQGYXPLOCK &lt; 4： &lt;RPLNDVHGFCUKTEBSXQYIZMJWAO &lt; 5： &lt;IHFRLABEUOTSGJVDKCPMNZQWXY &lt; 6： &lt;AMKGHIWPNYCJBFZDRUSLOQXVET &lt; 7： &lt;GWTHSPYBXIZULVKMRAFDCEONJQ &lt; 8： &lt;NOZUTWDCVRJLXKISEFAPMYGHBQ &lt; 9： &lt;QWATDSRFHENYVUBMCOIKZGJXPL &lt; 10： &lt;WABMCXPLTDSRJQZGOIKFHENYVU &lt; 11： &lt;XPLTDAOIKFZGHENYSRUBMCQWVJ &lt; 12： &lt;TDSWAYXPLVUBOIKZGJRFHENMCQ &lt; 13： &lt;BMCSRFHLTDENQWAOXPYVUIKZGJ &lt; 14： &lt;XPHKZGJTDSENYVUBMLAOIRFCQW &lt; 密钥：2,5,1,3,6,4,9,7,8,14,10,13,11,12 密文：HCBTSXWCRQGLES 具体的过程 先按密钥行排列 2： &lt;KPBELNACZDTRXMJQOYHGVSFUWI &lt; 5： &lt;IHFRLABEUOTSGJVDKCPMNZQWXY &lt; 1： &lt;ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt; 3： &lt;BDMAIZVRNSJUWFHTEQGYXPLOCK &lt; 6： &lt;AMKGHIWPNYCJBFZDRUSLOQXVET &lt; 4： &lt;RPLNDVHGFCUKTEBSXQYIZMJWAO &lt; 9： &lt;QWATDSRFHENYVUBMCOIKZGJXPL &lt; 7： &lt;GWTHSPYBXIZULVKMRAFDCEONJQ &lt; 8： &lt;NOZUTWDCVRJLXKISEFAPMYGHBQ &lt; 14：&lt;XPHKZGJTDSENYVUBMLAOIRFCQW &lt; 10：&lt;WABMCXPLTDSRJQZGOIKFHENYVU &lt; 13：&lt;BMCSRFHLTDENQWAOXPYVUIKZGJ &lt; 11：&lt;XPLTDAOIKFZGHENYSRUBMCQWVJ &lt; 12：&lt;TDSWAYXPLVUBOIKZGJRFHENMCQ &lt; 再按密文调整每行顺序 2： &lt;HGVSFUWIKPBELNACZDTRXMJQOY&lt; 5： &lt;CPMNZQWXYIHFRLABEUOTSGJVDK&lt; 1： &lt;BVIQHKYPNTCRMOSFEZWAXJGDLU&lt; 3： &lt;TEQGYXPLOCKBDMAIZVRNSJUWFH&lt; 6： &lt;SLOQXVETAMKGHIWPNYCJBFZDRU&lt; 4： &lt;XQYIZMJWAORPLNDVHGFCUKTEBS&lt; 9： &lt;WATDSRFHENYVUBMCOIKZGJXPLQ&lt; 7： &lt;CEONJQGWTHSPYBXIZULVKMRAFD&lt; 8： &lt;RJLXKISEFAPMYGHBQNOZUTWDCV&lt; 14：&lt;QWXPHKZGJTDSENYVUBMLAOIRFC&lt; 10：&lt;GOIKFHENYVUWABMCXPLTDSRJQZ&lt; 13：&lt;LTDENQWAOXPYVUIKZGJBMCSRFH&lt; 11：&lt;ENYSRUBMCQWVJXPLTDAOIKFZGH&lt; 12：&lt;SWAYXPLVUBOIKZGJRFHENMCQTD&lt; flag：XSXSBUGKUADMIN 解密代码 #秘钥 key=&quot;2,5,1,3,6,4,9,7,8,14,10,13,11,12&quot; #密文 cipher_text = &quot;HCBTSXWCRQGLES&quot; f = open(&quot;zhuanlun.txt&quot;) str_first_encry = [] for line in f: line = line.strip() str_first_encry.append(line) key_index = key.split(&quot;,&quot;) str_second_encry=[] for k in key_index: str_second_encry.append(str_first_encry[int(k)-1]) print(str_first_encry[int(k)-1]) for i,ch in enumerate(cipher_text): line = str_second_encry[i] split_index = line.index(ch) temp=[] temp[0:len(line)-split_index+1] = line[split_index:len(line)] temp[len(temp):] = line[0:split_index] str_second_encry[i] = &quot;&quot;.join(temp) print(&quot;-------------------------------------&quot;) for plain in str_second_encry: print(plain) zhuanlun.txt ZWAXJGDLUBVIQHKYPNTCRMOSFE KPBELNACZDTRXMJQOYHGVSFUWI BDMAIZVRNSJUWFHTEQGYXPLOCK RPLNDVHGFCUKTEBSXQYIZMJWAO IHFRLABEUOTSGJVDKCPMNZQWXY AMKGHIWPNYCJBFZDRUSLOQXVET GWTHSPYBXIZULVKMRAFDCEONJQ NOZUTWDCVRJLXKISEFAPMYGHBQ QWATDSRFHENYVUBMCOIKZGJXPL 0WABMCXPLTDSRJQZGOIKFHENYVU XPLTDAOIKFZGHENYSRUBMCQWVJ TDSWAYXPLVUBOIKZGJRFHENMCQ BMCSRFHLTDENQWAOXPYVUIKZGJ XPHKZGJTDSENYVUBMLAOIRFCQW 棋盘密码 棋盘密码（Polybius）棋盘密码是一种查表加密法，密码表如下： 1 2 3 4 5 1 a b c d e 2 f g h i,j k 3 l m n o p 4 q r s t u 5 v w x y z 密文就是字符在密码表里面对应的横纵坐标，如&quot;a&quot;加密为&quot;11&quot;, “y&quot;加密为&quot;54” Welcome to pangolin lab! =&gt;Polybius=&gt; 52153113343215 4434 3511332234312433 311112! ADFGX/ADFGVX密码 ADFGX/ADFGVX密码与棋盘密码原理相似，只是将行号和列号换成了ADFGX/ADFGVX字母，且表格内的字母顺序可以人为确定，ADFGVX密码比ADFGX新增了数字。下面是两个可能的密码表： ADFGX: A D F G X A P H Q G M D E A Y N O F F L R C B G D S T U V X W Z X V I ADFGVX: A D F G V X A P H 0 Q G M D E A 1 Y N O F 2 F L R C B G 3 D S T U V V W 4 Z 5 X 6 X 7 8 9 0 1 2 ","link":"https://blog.rzly.net/post/hmisl_crypto_1/"},{"title":"「回中网安」2：动手实践初步入门-学习单","content":"动手实践初步入门-学习单 1：Basic-Linux Labs 题目链接：https://buuoj.cn/challenges#Linux%20Labs 这道题目，大家需要学会一些Linux的基本命令，并使用适合的链接工具连接靶场进行攻防测试 题目提示：ssh 用户名：root 密码：123456 地址和端口为动态分配的 看到提示就发现它给了我们一个root最高权限用户的操作用户，因此猜测答案就在某个目录下 因此启动靶场后使用FinalShell连接服务器 FinalShell使用教程 打开FinalShell 创建连接 输入主机名和端口号，以及账号密码 双击连接 掌握基本命令 根据主机名称提示，发现提示我们out 我们尝试返回上级目录，使用命令cd ../ 使用ls命令列出当前目录下的所有文件 发现flag.txt文件 使用cat flag.txt输出文件内容 至此，成功获得flag，提交成功！ 2：Crypto-一眼就解密 题目链接：https://buuoj.cn/challenges#%E4%B8%80%E7%9C%BC%E5%B0%B1%E8%A7%A3%E5%AF%86 打开题目发现提示如下： 下面的字符串解密后便能获得flag：ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30= 注意：得到的 flag 请包上 flag{} 提交 观察以下内容ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=发现应该是base加密族内容，通过特征推测是base64加密，因此找到有关解密工具，例如：https://www.qqxiuzi.cn/bianma/base.php 解密后发现flag为：flag{THE_FLAG_OF_THIS_STRING} 知识点：base加密族 编码方式 特征 base16 用于编码的字符只有：1-9，A-F ,只有简单的15个字符 base32 编码字符有了明显改变，由base16的类型转变为了A-Z,2-7 base64 最完善，在base32的基础上，增加了&quot;a-z,0,1,8,9,+,/&quot;，以及特殊填充字符&quot;=&quot; Base-64编码将一个8位子节序列拆散为6位的片段，并为每个6位的片短分配一个字符，这个字符是Base-64字母表中的64个字符之一。 3：Misc-金三胖 题目链接：https://buuoj.cn/challenges#%E9%87%91%E4%B8%89%E8%83%96 大家可以自行完成签到题目 题目没有给出任何提示，下载文件后解压发现一张图片，名为aaa.gif 打开图片发现中间快速闪烁有不正常的帧 因此我们把它逐帧分析，可以拖入stegsolve完成 选中frame browser，发现在第21帧、第51帧、第79帧有flag 得到flag 4：Pwn-test_your_nc 题目链接：https://buuoj.cn/challenges#test_your_nc 知识点：nc命令 nc命令使用help： nc [-hlnruz][-g&lt;网关...&gt;][-G&lt;指向器数目&gt;][-i&lt;延迟秒数&gt;][-o&lt;输出文件&gt;][-p&lt;通信端口&gt;][-s&lt;来源位址&gt;][-v...][-w&lt;超时秒数&gt;][主机名称][通信端口...] 参数说明： -g&lt;网关&gt; 设置路由器跃程通信网关，最多可设置8个。 -G&lt;指向器数目&gt; 设置来源路由指向器，其数值为4的倍数。 -h 在线帮助。 -i&lt;延迟秒数&gt; 设置时间间隔，以便传送信息及扫描通信端口。 -l 使用监听模式，管控传入的资料。 -n 直接使用IP地址，而不通过域名服务器。 -o&lt;输出文件&gt; 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。 -p&lt;通信端口&gt; 设置本地主机使用的通信端口。 -r 乱数指定本地与远端主机的通信端口。 -s&lt;来源位址&gt; 设置本地主机送出数据包的IP地址。 -u 使用UDP传输协议。 -v 显示指令执行过程。 -w&lt;超时秒数&gt; 设置等待连线的时间。 -z 使用0输入/输出模式，只在扫描通信端口时使用。 Linux nc命令的实例 TCP端口扫描 nc -v -z -w2 192.168.0.1 1-100 UDP端口扫描 nc -u -z -w2 192.168.0.1 1-1000 扫描指定端口 nc -nvv 192.168.0.1 80 监听入站连接 nc -l 8080 连接远程系统 nc 192.168.0.1 80 连接UDP端口 nc -l -u 1234 将nc作为代理 发往我们服务器8080端口的连接都会自动转发到192.168.1.200上的80端口 nc -l 8080 | nc 192.168.1.200 80 使用nc拷贝文件 nc还能用来在系统间拷贝文件，虽然这么做并不推荐，因为绝大多数系统默认都安装了ssh/scp。不过如果你恰好遇见个没有ssh/scp的系统的话，你可以用nc来作最后的努力。 在要接受数据的机器上启动nc并让它进入监听模式： nc -l 8080 &gt; file.txt 现在去要被拷贝数据的机器上运行下面命令： nc 192.168.1.100 8080 --send-only &lt; data.txt 通过nc创建后门 nc -l 10000 -e /bin/bash -e标志将一个bash与端口10000相连。现在客户端只要连接到服务器上的10000端口就能通过bash获取我们系统的完整访问权限： nc 192.168.1.100 10000 通过nc进行端口转发 所有连接到80端口的连接都会转发到8080端口 nc -u -l 80 -c 'ncat -u -l 8080' 解题思路 题目提示使用nc命令，则猜测只需要连接远程系统即可像Basic-Linux Labs一样直接获取Flag内容因此打开WSL下的Kali Linux，输入 nc [靶场IP] [靶场端口] 例如实践中靶场是node5.buuoj.cn:26335 则输入 nc node5.buuoj.cn 26335 然后发现在当前目录下就存在flag文件，类似于Basic-Linux Labs直接通过cat命令显示 5：Reverse-easyre 题目链接：https://buuoj.cn/challenges#easyre 下载解压得到easyre.exe文件，运行结束发现告诉我们不能得到flag，由于题目简单，我们尝试使用静态逆向工具IDA Pro 使用IDA Pro打开文件逆向分析后发现flag在一个变量中，直接复制提交即可 6：Web-[极客大挑战 2019]EasySQL 题目链接：https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]EasySQL 题目分析 这是我们第一次接触一个网页来攻击，打开网页发现有两个地方让我们输入用户名和密码，因此，我们认为突破口在这里 尝试使用弱密码攻击admin和123，提示NO,Wrong username password！！！但是请求地址变为 check.php?username=admin&amp;password=123 又因为题目为EasySQL，所以尝试使用SQL注入攻击，payload如下内容 ?username=1' and 1=1 &amp;password=1' and 1=1 来测试有没有数据库注入漏洞，发现回显 You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near '' and password='1' and 1=1'' at line 1 知识点：SQL注入原理及如何判断闭合符 造成SQL注入的原因： 在没有对用户的输入进行过滤、检测的情况下，就把用户输入数据，带入到数据库中执行SQL语句。 利用SQL注入： 由于系统没有对输入的数据进行过滤、检测，就带入到数据库中执行SQL语句，那么当用户输入一条恶意的数据，使其与原SQL语句拼接、重组得到一条恶意的SQL语句，当数据库执行这条恶意的SQL语句时，就会把数据库中的信息暴露出来，从而泄露信息。 一般的代码： id=id=id=_GET[‘id’]; sql=“SELECT \\* FROM name WHERE id=’id’ LIMIT 0,1”; 我们可以看到，用户输入的id是被带到sql语句中进行拼接，然后执行的，而且，这个id两边是被’ ‘(两个单引号)给闭合起来的，所以在这个代码里**’(单引号)就是闭合符** 由此，若是我们想进行SQL注入，那么就可以通过给定id一些恶意的数据，让这些恶意的数据与原SQL语句结合在一起，构成一个新的、恶意的SQL语句，让这个恶意的SQL语句执行成功，从而达到SQL注入的目的。 防止SQL注入的措施 SQL语句的执行代码使用预编译 PreparedStatement 确定每个数据的类型，比如是数字，数据库则必须使用int类型来存储 限制传入数据的长度，这能够在一定程度上防止sql注入 严格限制用户使用数据库的权限，能够在一定程度上减少sql注入的危害 避免直接响应一些 sql 语句执行异常的信息 过滤参数中含有的一些数据库关键词 因此我们发现这个网站的闭合方式为单引号 知识点：MySQL中单引号，双引号和反引号的区别 单引号 一般应使用英文单引号，如果字符串内需要包含单引号时，除了使用转义的办法外，我们可以选用一对双引号来包括字符串，这样字符串内的单引号被视作普通字符，无需特殊处理 例如 Johnson's mother select &quot;Johnson's mother&quot;,'Johnson''s mother','Johnson\\'s mother'; 双引号 与单引号对应，使用英文双引号引用的字符串内需要包含双引号时，除了使用转义的办法外，我们可以用一对单引号来包括字符串，这样字符串内的双引号被视作普通字符，无需特殊处理。 例如 He said: &quot;Go away&quot; select 'He said: &quot;Go away&quot;' ,&quot;He said: &quot;&quot;Go away&quot;&quot;&quot; ,&quot;He said: \\&quot;Go away\\&quot;&quot; ; 反引号 反引号，一般在ESC键的下方。它是为了区分MYSQL的保留字与普通字符而引入的符号。 MySQL里使用一对反勾号“ ` ”将识别符括起来，一般情况下可以不用，单是如果识别符出现关键字冲突或标识符的写法可能产生歧义的情况下就必须使用。例如： create table t1 (id int primary key ,desc varchar(10)); -- 这句会报错 create table t1 (id int primary key,`desc` varchar(10)); -- 这句客成功运行 举个例子： 在test表中，有个select字段，如果不用反引号，MYSQL将把select视为保留字而导致出错，所以，有MYSQL保留字作为字段的，必须加上反引号来区分。 SELECT `select` FROM `test` WHERE select='字段值' 另外：建表的时候一般都会将表名，库名都加上反引号来保证语句的执行度。反引号`，数字1左边的符号。 保留字不能用于表名，比如desc，此时需要加入反引号来区别，但使用表名时可忽略反引号。 create table desc -- 报错 create table `desc` -- 成功 create table `test` -- 成功 drop table test -- 成功 保留字不能用于字段名，比如desc，此时也需要加入反引号，并且insert等使用时也要加上反引号。 create table `test`（`desc` varchar(255)） -- 成功 insert into test(desc) values('fxf') -- 失败 insert into test(`desc`) values('fxf') -- 成功 使用Sql注入解题 一般来说，有账号密码登陆的题，在判断完闭合方式后，可以尝试先用万能账号密码解题 使用万能账号a' or true #登录，发现成功进入获取flag！ 知识点：万能账号密码原理剖析 一个网络安全意识淡薄的网站，其登录功能的SQL语句大概是下面这个样子 select \\* from user where username='user' and password='pass' 万能账号 万能账号并不是一个真正意义上的账号，它是一种【拥有不同变体的格式】 需要注意的是，以下所有万能账号中的 a 可以是自定义的数字或字母，比如 1，2，3，b，c，d 【数值型万能账号】 a or true # a or 1 # a or 1=1 # a or true -- a a or 1 -- a a or 1=1 -- a 【单引号字符型万能密码】 a' or true # a' or 1 # a' or 1=1 # a' or true --a a' or 1 -- a a' or 1=1 -- a 【双引号字符型万能密码】 a&quot; or true # a&quot; or 1 # a&quot; or 1=1 # a&quot; or true -- a a&quot; or 1 -- a a&quot; or 1=1 -- a 万能账号原理 当我们在登录界面输入 【万能账号】比如 a’ or true # 以后，后端会将我们输入的参数拼接到SQL中，然后去数据库中查询账号和密码，SQL语句大概是下面这样 select \\* from user where username='a' or true #' and password='pass' 由于 # 在SQL中是注释符，注释符后面的内容不起作用，所以真正执行的SQL语句大概是下面这样 select \\* from user where username='a' or true or true 会使SQL语句恒成立，从而查询出数据库中的所有账号和密码，从而使我们成功登录 注释符 除了 # 以外， -- 也是SQL中的注释符，但SQL的语法格式规定--和后面的注释内容必须间隔一个空格，所以这需要使用 a' or 1 -- a 而不是 a' or 1 -- 其原理和 a’ or 1 # 大同小异，拼接到SQL中大概是下面这样 select \\* from user where username='a' or true -- a' and password='pass' 注释后面的内容不生效，真正执行的SQL大概是下面这样 select \\* from user where username='a' or true SQL语句恒成立，从而登录成功 换句话来说，a' or true -- a经过SQL的转化后，结果等价于 a’ or true # 比较运算符 SQL中规定，非布尔类型的数据参与比较运算时，会转化为布尔类型再参与运算。比如 or 1 或者 or 1=1 ，会转化为布尔类型的 true 再参与 or 的比较运算，也就是变成 or true ，同样能使条件恒成立，从而登录成功 简单来讲就是：a' or 1 # 或者 a' or 1=1 # 等价于 a' or true # 万能密码 万能密码并不是一个真正意义上的密码，而是一个【拥有不同变体的格式】 需要注意的是：万能密码中的 admin，必须是真实的用户名 【数值型万能密码】 admin # admin -- a 【单引号字符串型万能密码】 admin' # admin' -- a 【双引号字符串型万能密码】 admin” # admin&quot; -- a 万能密码原理 当我们在登录界面输入 【万能密码】 比如 admin’ # 以后，后端会将我们输入的参数拼接到SQL中，大概是下面这样 select \\* from user where username='admin' #' and password='pass' 由于 # 在SQL中是注释符，注释符后面的内容不起作用，所以真正执行的SQL大概是下面这样 select \\* from user where username='admin' SQL只会在数据库中查询用户名，而不是同时查询用户名和密码，这就意味着，只要用户名正确，就可以登录成功 ","link":"https://blog.rzly.net/post/hmisl_course_2/"},{"title":"Windows联网后却显示未联网的一种解决方案","content":"问题原因 「网络连接状态」的出现和 Windows 判定当前设备互联网连接状态的方式有关。 当电脑连接到有线网络或者无线网络后，Windows 会发送请求到微软的特定服务器，服务器成功收到请求后会返回值确定「设备已经拥有了正常的网络访问功能」；如果请求后 Windows 系统没有收到微软服务器返回的值，则会被判定为「无 Internet 访问」。 微软在某次版本更新修改了这个服务器，导致有些人连接不上，所以说我们只需要把它改回去！ 解决方案 首先把一下代码保存为reg文件，然后合并重启即可 Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\NlaSvc\\Parameters\\Internet] &quot;ActiveWebProbeContent&quot;=&quot;Microsoft NCSI&quot; &quot;ActiveWebProbeContentV6&quot;=&quot;Microsoft NCSI&quot; &quot;ActiveWebProbeHost&quot;=&quot;www.msftncsi.com&quot; &quot;ActiveWebProbeHostV6&quot;=&quot;ipv6.msftncsi.com&quot; &quot;ActiveWebProbePath&quot;=&quot;ncsi.txt&quot; &quot;ActiveWebProbePathV6&quot;=&quot;ncsi.txt&quot; &quot;EnableActiveProbing&quot;=dword:00000001 ","link":"https://blog.rzly.net/post/windows_network_patch/"},{"title":"Arduino 开发笔记 <持续更新>","content":" 本笔记部分内容参考于网络 Arduino是什么？ 开始讲之前跟大家普及一个知识点，Arduino是一个意大利品牌。Arduino是一个开放源码电子原型平台，拥有灵活、易用的硬件(各种开发板)和软件（Arduino IDE也就是编程器）。吉安优创电子科技有限公司作为arduino国内为数不多的正版授权公司，坚持正版。打击抵制各类盗版，改版，兼容版的侵权行为，也奉劝广大消费者不要去购买，以免带来不必要的麻烦。Arduino专为设计师，工艺美术人员，业余爱好者，以及对开发互动装置或互动式开发环境感兴趣的人而设的。 Arduino能通过各种各样的传感器来感知环境，通过控制灯光、马达和其他的装置来反馈、影响环境。板子上的微控制器可以通过Arduino的编程语言来编写程序，编译成二进制文件，烧录进微控制器 对Arduino的编程是利用 Arduino编程语言 (基于 Wiring)和Arduino开发环境(based on Processing)来实现的。基于Arduino的项目，可以只包含Arduino，也可以包含Arduino和其他一些在PC上运行的软件，他们之间进行通信 (比如 Flash, Processing, MaxMSP)来实现。 认识Arduino UNO Arduino UNO是Arduino入门的最佳选择，在编著本书时，其最新的版本为UNO R3，本书大部分内容都是基于Arduino UNO R3写成的。Arduino UNO的详细组成信息如下图所示。 电源（Power） Arduino UNO有三种供电方式： 通过USB接口供电，电压为5V； 通过DC电源输入接口供电，电压要求7～12V； 通过电源接口处5V或者VIN端口供电，5V端口处供电必须为5V，VIN端口处 供电为7～12V。 指示灯（LED） Arduino UNO带有4个LED指示灯，作用分别是： ON，电源指示灯。当Arduino通电时，ON灯会点亮。 TX，串口发送指示灯。当使用USB连接到计算机且Arduino向计算机传输数据 时，TX灯会点亮。 RX，串口接收指示灯。当使用USB连接到计算机且Arduino接收计算机传来的 数据时，RX灯会点亮。 L，可编程控制指示灯。该LED通过特殊电路连接到Arduino的13号引脚，当 13号引脚为高电平或高阻态时，该LED会点亮；当为低电平时，不会点亮。因 此可以通过程序或者外部输入信号来控制该LED的亮灭。 复位按键（Reset Button） 按下该按键可以使Arduino重新启动，从头开始运行程序。 存储空间（Memory） Arduino的存储空间即是其主控芯片所集成的存储空间。也可以通过使用外设芯片的方式来扩展Arduino的存储空间。Arduino UNO的存储空间分三种： Flash，容量为32KB。其中0.5KB作为BOOT区用于储存引导程序，实现通过串 口下载程序的功能；另外的31.5KB作为用户储存的空间。相对于现在动辄几百 GB的硬盘，可能觉得32KB太小了，但是在单片机上，32KB已经可以存储很大 的程序了。 SRAM，容量为2KB。SRAM相当于计算机的内存，当CPU进行运算时，需要 在其中开辟一定的存储空间。当Arduino断电或复位后，其中的数据都会丢失。 EEPROM，容量为1KB。EEPROM的全称为电可擦写的可编程只读存储器，是 一种用户可更改的只读存储器，其特点是在Arduino断电或复位后，其中的数据 不会丢失。 5.输入/输出端口（Input/Output Port） 如图1-20所示，Arduino UNO有14个数字输入/输出端口，6个模拟输入端口。其中一些带有特殊功能，这些端口如下： UART通信，为0（RX）和1（TX）引脚，被用于接收和发送串口数据。这两个 引脚通过连接到ATmega16U2来与计算机进行串口通信。 外部中断，为2和3引脚，可以输入外部中断信号。 PWM输出，为3、5、6、9、10和11引脚，可用于输出PWM波。 SPI通信，为10（SS）、11（MOSI）、12（MISO）和13（SCK）引脚，可用于 SPI通信。 TWI通信，为A4（SDA）、A5（SCL）引脚和TWI接口，可用于TWI通信，兼 容IIC通信。 AREF，模拟输入参考电压的输入端口。 Reset，复位端口。接低电平会使Arduino复位。当复位键被按下时，会使该端口 接到低电平，从而使Arduino复位。 Arduino IDE开发环境 在开始使用Arduino之前，需要在电脑上安装Arduino的集成开发环境（此后简称IDE）。老版本运行速度等更好更快，新版本继续Chrome内核，速度变慢，稳定性差一些，推荐使用老版本，下载地址为：https://www.arduino.cc/en/software/OldSoftwareReleases 双击桌面的软件图标，进入Arduino IDE之后。如下图所示 在工具栏上， Arduino IDE提供了常用功能的快捷键： 相对于IAR、Keil等专业的硬件开发环境，Arduino的开发环境给人以简单明了的感觉，但正是这种简单，省去了很多不常用的功能，使得基础知识不多的使用者更容易上手。 默认安装后会自动安装驱动，连接就可以使用！ Hello_World实验 实验器件 UNO控制板：1 个 USB数据线：1 条 实验连线 程序代码 int val;//定义变量val int ledpin=13;//定义数字接口13 void setup() { Serial.begin(9600);//设置波特率为9600，这里要跟软件设置相一致。当接入特定设备（如：蓝牙）时，我们也要跟其他设备的波特率达到一致。 pinMode(ledpin,OUTPUT);//设置数字13 口为输出接口，Arduino 上我们用到的I/O 口都要进行类似这样的定义。 } void loop() { val=Serial.read();//读取PC 机发送给Arduino 的指令或字符，并将该指令或字符赋给val if(val=='R')//判断接收到的指令或字符是否是“R”。 { //如果接收到的是“R”字符 digitalWrite(ledpin,HIGH);//点亮数字13 口LED。 delay(500); digitalWrite(ledpin,LOW);//熄灭数字13 口LED delay(500); Serial.println(&quot;Hello World!&quot;);//显示“Hello World！”字符串 } } 实验结论 打开串口监视器，在串口监视器内输入“R”。 开发板上的13号LED灯会闪一下；串口监视器会收到来自Arduino的信息Hello World ","link":"https://blog.rzly.net/post/arduino_notebook/"},{"title":"一些比较优秀的语录~","content":"宫崎骏治愈焦虑的一段话 你只是来体验生命的， 你什么都拥有不了， 也留不住。 不需要证明什么， 没有什么事是必须要实现的， 你要做的就是： 不断尝试收获，然后放下。 我们来到人世间， 是为了看花怎么开， 水怎么流， 太阳何时升起， 夕阳何时落下。 经历有趣的事， 遇见难忘的人。 生活原本沉闷，但跑起来就有风了…… 我们要允许新的生活， 开始发生。 有时候老天会跟你开一个玩笑， 其实是为了让你有机会选择新的生活， 开始新的生活， 这很难， 但你要相信自己， 你远比你想象中的要坚强！ ","link":"https://blog.rzly.net/post/better_quotes/"},{"title":"Debian安装时换源方法","content":"问题起因 Debian安全源地址会使用Debian的官方国外源，非常的慢，把它换掉会好很多 解决方案 在安装步骤进入到选择安装的桌面环境和软件时, 键入Ctrl+Alt+F2 进入tty命令终端Enter 修改软件源头 nano /target/etc/apt/sources.list Ctrl+X 退出保存 退出终端重新进入界面继续安装，Ctrl+Alt+F5 ","link":"https://blog.rzly.net/post/debian_install_sources/"},{"title":"使用GitHub Action在repo指定目录中创建GitHub贡献贪吃蛇svg","content":"#代码展示 name: generate animation permissions: contents: write on: schedule: - cron: &quot;0 2 * * *&quot; workflow_dispatch: push: branches: - main jobs: generate: runs-on: ubuntu-latest timeout-minutes: 10 steps: - uses: actions/checkout@v4 - name: generate github-contribution-grid-snake.svg uses: Platane/snk/svg-only@v3 with: github_user_name: ${{ github.repository_owner }} outputs: | ./static/svg/snake-Light.svg ./static/svg/snake-Dark.svg - name: Push to GitHub uses: EndBug/add-and-commit@v9.1.4 with: message: 'Generate Contribution Snake' add: '*.svg --force' 修改代码 注意，./static/svg/snake-Light.svg以及./static/svg/snake-Dark.svg应当被修改为您的目录。 成果展示 ","link":"https://blog.rzly.net/post/github_action_snake/"},{"title":"GitBook基于MarkDown制作电子书","content":"安装特定版本的Node.js GitBook项目已经停止维护，所以说不支持最新版本的Node.js，我们需要安装旧版本的Node.js。 经过大量测试后发现V10.24.1是可以正常运作GitBook的。以下是下载链接 https://nodejs.org/download/release/v10.24.1/ 请按照需要下载特定版本 如果之前下载过高版本需要彻底卸载或者使用多版本管理器 通过 npm 安装 gitbook-cli 安装命令（使用cmd或其他命令方式安装）： npm install -g gitbook-cli 执行gitbook -V查看是否正确安装 $ gitbook -V CLI version: 2.3.2 GitBook version: 3.2.3 安装ebook-convert ebook-convert 是能够自由转化格式的一个命令行工具，包含在 calibre 软件中 WIndows用户 在官网： https://calibre-ebook.com/ 下载安装 安装后在命令行执行ebook-convert --version查看是否安装成功 $ ebook-convert --version ebook-convert.exe (calibre 7.7.0) Created by: Kovid Goyal &lt;kovid@kovidgoyal.net&gt; 如果安装后没有出现，则需要将安装目录添加到PATH中！ Mac用户 在官网： https://calibre-ebook.com/ 下载安装 执行如下命令，把 ebook-convert 软链接到 bin 目录： sudo ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/bin 如果出现Operation not permitted异常，说明系统权限限制，此时需要配置环境变量。 vim编辑~/.bash_profile vim ~/.bash_profile # 将下面这两行配置，添加到 .bash_profile 文件中 export EBOOK_PATH=/Applications/calibre.app/Contents/MacOS export PATH=$PATH:$EBOOK_PATH 刷新刚刚的配置 source ~/.bash_profile 验证ebook-convert是否能正常使用： ebook-convert --version Linux用户 与Mac类似，不多加赘述。 配置电子书的目录 在本地新建一个空目录，用来存放电子书和配置文件等 项目初始化 gitbook init 此时，项目下会自动生成如下两个文件：（非常重要，必不可少） README.md：书籍的简介放在这个文件里。 SUMMARY.md：书籍的目录结构在这里配置。 配置电子书的目录 我们先把本地的 markdown 文件（也就是我们的电子书素材）放到项目中，然后在SUMMARY.md文件中配置电子书的目录（因为发现这一部分比我写得好，以下部分内容转载自知乎 https://zhuanlan.zhihu.com/p/245763905 ） 比如说， 我的项目中有下面这些文件： 那么，我在SUMMARY.md文件中就要这样配置： # 目录 * [README](./README.md) * [00-前端工具](00-前端工具/0-README.md) * [01-VS Code的使用](00-前端工具/01-VS Code的使用.md) * [02-Git的使用](00-前端工具/02-Git的使用.md) * [01-HTML](01-HTML/0-README.md) * [01-认识Web和Web标准](01-HTML/01-认识Web和Web标准.md) * [02-浏览器的介绍](01-HTML/02-浏览器的介绍.md) * [03-初识HTML](01-HTML/03-初识HTML.md) * [02-CSS基础](02-CSS基础/0-README.md) * [01-CSS属性：字体属性和文本属性](02-CSS基础/01-CSS属性：字体属性和文本属性.md) * [02-CSS属性：背景属性](02-CSS基础/02-CSS属性：背景属性.md) * [03-CSS样式表和选择器](02-CSS基础/03-CSS样式表和选择器.md) * [03-JavaScript基础](03-JavaScript基础/0-README.md) * [00-编程语言](03-JavaScript基础/00-编程语言.md) * [01-JS简介](03-JavaScript基础/01-JS简介.md) * [02-变量](03-JavaScript基础/02-变量.md) * [03-变量的数据类型：基本数据类型和引用数据类型](03-JavaScript基础/03-变量的数据类型：基本数据类型和引用数据类型.md) 制作成的目录，将会是下面这种效果： 导出电子书 本地预览 gitbook serve 执行上方命令后，工具会对项目里的 Markdown 格式的文件进行转换，默认转换为 html 格式，最后提示 Serving book on http://localhost:4000。 我们打开浏览器输入http://localhost:4000，预览一下电子书的效果： 制作并导出电子书 生成 PDF 格式的电子书：（PDF 是最常见的文档格式） gitbook pdf ./ ./mybook.pdf 生成 epub 格式的电子书：（epub 是最常见、最通用的电子书格式） gitbook epub ./ ./mybook.epub 生成 mobi 格式的电子书：（mobi 格式可以在 kindle 中打开） gitbook mobi ./ ./mybook.mobi 上面这三种格式的电子书生成之后，项目里会看到这三个新增的文件 高级配置 制作书籍封面 为了让书籍显示得更加优雅，我们可以指定一个自定义的封面。操作如下： 在项目的根目录下准备好 cover.jpg （大封面）和 cover_small.jpg （小封面）这两种封面图片。注意，图片的文件名和后缀名必须严格按照这句话来。 GitBook 的官方文档建议： cover.jpg （大封面）的尺寸为 1800x2360 像素，cover_small.jpg（小封面）的尺寸为 200x262 像素。图片的制作，建议遵循如下规范： 没有边框 清晰可见的书本标题 任何重要的文字在小封面中应该清晰可见 book.json ：电子书的各种配置 我们可以在项目的根目录下新建一个文件book.json，这个book.json就是电子书的配置文件，可以在里面填一些常见的配置。 1、常规配置如下： 变量 描述 root 包含所有图书文件的根文件夹的路径，除了 book.json structure 指定自述文件，摘要，词汇表等的路径 title 您的书名，默认值是从 README 中提取出来的。在 GitBook.com 上，这个字段是预填的。 description 您的书籍的描述，默认值是从 README 中提取出来的。在 GitBook.com 上，这个字段是预填的。 author 作者名。在GitBook.com上，这个字段是预填的。 isbn 国际标准书号 ISBN language 本书的语言类型 —— ISO code 。默认值是 en direction 文本阅读顺序。可以是 rtl （从右向左）或 ltr （从左向右），默认值依赖于 language 的值。 gitbook 应该使用的GitBook版本，并接受类似于 &gt;=3.0.0 的条件。 links 在左侧导航栏添加链接信息 plugins 要加载的插件列表(官网插件列表) pluginsConfig 插件的配置 示例：配置 book.json 的示例如下： { &quot;title&quot;: &quot;前端入门和进阶图文教程&quot;, &quot;description&quot;: &quot;前端入门到进阶图文教程，超详细的Web前端学习笔记。从零开始学前端，做一名精致优雅的前端工程师。公众号「千古壹号」作者。&quot;, &quot;author&quot;: &quot;千古壹号&quot;, &quot;language&quot;: &quot;zh-hans&quot;, &quot;gitbook&quot;: &quot;3.2.3&quot;, } 2、pdf 的配置如下：（使用 book.json 中的一组选项来定制 PDF 输出） 配置项 描述 pdf.pageNumbers 将页码添加到每个页面的底部（默认为 true） pdf.fontSize 基本字体大小（默认是 12） pdf.fontFamily 基本字体样式（默认是 Arial） pdf.paperSize 页面尺寸，选项有： a0、a1、 a2、 a3、a4、a5、a6、b0、b1、b2、b3、b4、b5、b6、legal、letter （默认值是 a4） pdf.margin.top 上边距（默认值是 56） pdf.margin.bottom 下边距（默认值是 56） pdf.margin.left 左边距（默认值是 62） pdf.margin.right 右边距（默认值是 62） 定制 PDF 文档输出格式的示例代码如下： { &quot;pdf&quot;: { &quot;pageNumbers&quot;: false, &quot;fontSize&quot;: 12, &quot;paperSize&quot;: &quot;a4&quot;, &quot;margin&quot;: { &quot;top&quot;: 36, &quot;bottom&quot;: 36, &quot;left&quot;: 62, &quot;right&quot;: 62 } } } 备注：如果你不需要对输出的 pdf 做任何特定的配置，则不需要添加上面的内容，让 pdf 的输出格式保持默认就好。 3、plugins 插件： 默认插件： highlight - 语法高亮插件 search - 搜索插件 sharing - 分享插件 font-settings - 字体设置插件 livereload - 热加载插件 由于制作电子书不需要插件，如果有网页搭建等需求，可以查看 https://blog.csdn.net/gongch0604/article/details/107494736 自动生成目录（重要） 如果你的电子书素材里有很多 markdown 文件，那么，如何将多个 markdown 文件的文件名，在SUMMARY.md里快速生成对应的目录？ 难道要一个一个地手动 copy 吗？这不可能。 说白了，这个需求就是：如何自动生成电子书的目录？改变世界的程序员用「脚本」就能搞定，一键执行。 网上有很多好用的脚本，我给你推荐一个亲测好用的脚本： GitBook 自动生成目录的脚本：https://github.com/fushenghua/gitbook-plugin-summary 操作方法很简单，把上面这个链接中的项目下载下来，进入到这个项目的目录，执行 $ python gitbook-plugin-summary.py dirPath 即可自动生成电子书的目录，亲测有效。备注：这里的dirPath指的是你的电子书目录的绝对路径。 对了，在执行上面这个脚本之前，记得先安装 Python 环境。 电子书修正 经过测试只有epub的目录可以正常运转，因此我们可能需要使用Calibre再次编辑电子书。将EPUB文件拖入Calibre或者直接用Edit E-book打开，编辑书籍。 删除左侧杂项中可以删除的项目，这些项目将导致文章重复，并且目录构建在上面，让电子书的目录乱跳。 删除所有目录，然后点击更具大标题构建，如果出现带#xxx的重复项，删除即可 随后将目录嵌入书籍，会在左侧多出来一个toc.xhtml目录文件 这个时候就可以删除SUMMARY.html文件了，使用toc.xhtml目录文件，将其中指向目录的标签也改为toc.xhtml 电子书其他格式制作导出 将书籍导入Calibre（如果之前是导入编辑就不需要这样做） 点击转换书籍，在右上角选择转换格式 由于我们已经制作好目录，我们需要关闭目录导出选项 确定导出即可 保存最后的电子书 将最后导出的电子书保存到硬盘即可 😋大功告成！最终作品可以参考如下文件 https://github.com/iuu6/EnglishGrammarBook/tree/master/Output ","link":"https://blog.rzly.net/post/make_MD_Book/"},{"title":"隐藏Windows「安全删除硬件」里的USB/其他设备","content":"错误概述 前言：在学校维护希沃时，发现经常有人喜欢把希沃焊接在主板上的无线网卡弹出，影响上课（虽然重启就能恢复了） 解决方案 首先打开设备管理器（Win+R devmgmt.msc），找到要隐藏的设备 （由于不在校内，先使用自己电脑作为演示） 双击进入设备设置 关闭电源管理中的自动关闭此设备 在详细信息中找到硬件ID 修改注册表 打开注册表编辑器（Win+R regedit），定位到以下条目 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum 然后找到与设备硬件ID相符合的条目（开头为PCI就是PCI表内，USB就是USB表内）（希沃是USB），进入 由于电脑的这个网卡不支持修改（以下部分图片转载自PCBeta） 接着着双击 “硬件id”对应的注册表项打开对应的子项，右侧窗格有个WORD的名称为 “Capabilities”,记住你要修改的“Capabilities”所在的路径，等会要用。下图是我的“Capabilities”路径，每个电脑硬件Id不同后三部分的路径也不同。 修改“Capabilities”十进制下在原值上-4，这里我的原值十进制是22，-4后就是18，然后填上18，记住你-4后的十进制数值，之后还要用。 设置每次都这样 打开“boostmaster.exe”软媒优化大师，点击 “启动项” – 点击“添加开机启动项” add 你第五步修改的“Capabilities”所在路径 /v Capabilities /t REG_DWORD /d 你第五步修改后的“Capabilities”十进制的值 /f 例如： add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\PCI\\VEN_8086&amp;DEV_10D3&amp;SUBSYS_07D015AD&amp;REV_00\\000C29FFFF8CE83500 /v Capabilities /t REG_DWORD /d 18 /f 这样重启也不会还原啦~！ ","link":"https://blog.rzly.net/post/reg_disable_delete_devices/"},{"title":"基于Windows封装系统，Microsoft Store应用消失解决方案","content":"错误概览 Microsoft Store中有许多有用得功能，但是在封装时如果有联网操作或者其他操作不当，Microsoft Store应用也会变成单用户安装，不知道为什么。（参见[基于WIndows英文原版封装系统为中文时出现的错误修正]: https://blog.rzly.net/post/dism_install_for_all_user/） 错误分析 我们知道通过微软商城或者add-appxpackage命令安装的包都是仅仅为单用户安装了，所以说在封装系统新建的用户就没有这些包了 错误修正 我们可以在 https://store.rg-adguard.net/ 下载这些应用的官方安装包，注意下载后缀一般为.Msixbundle。 然后在封装执行前使用Dism安装，为了方便安装，可以使用以下Bat脚本。 @echo off setlocal enabledelayedexpansion REM 设置你的目录路径 set &quot;directory_path=C:\\Sysprep\\AppUpdate&quot; REM 进入指定的目录 cd /d &quot;%directory_path%&quot; REM 遍历目录下所有的.Msixbundle文件 for %%f in (*.Msixbundle) do ( REM 执行DISM命令 DISM /Online /Add-ProvisionedAppxPackage /packagePath:&quot;!directory_path!\\%%f&quot; /SkipLicense ) REM 结束批处理脚本 endlocal 注意：你需要把 C:\\Sysprep\\AppUpdate 修改为你的路径 ","link":"https://blog.rzly.net/post/msixbundle_for_all_user/"},{"title":"基于WIndows英文原版封装系统为中文时出现的错误修正","content":"报错概览 在日志文件setuperr.log中发现以下类似报错😅 2024-03-02 16:05:38, Error SYSPRP Package Microsoft.LanguageExperiencePackzh-CN_22621.41.188.0_neutral__8wekyb3d8bbwe was installed for a user, but not provisioned for all users. This package will not function properly in the sysprep image. 2024-03-02 16:05:38, Error SYSPRP Failed to remove apps for the current user: 0x80073cf2. 2024-03-02 16:05:38, Error SYSPRP Exit code of RemoveAllApps thread was 0x3cf2. 2024-03-02 16:05:38, Error SYSPRP ActionPlatform::LaunchModule: Failure occurred while executing 'SysprepGeneralizeValidate' from C:\\Windows\\System32\\AppxSysprep.dll; dwRet = 0x3cf2 2024-03-02 16:05:38, Error SYSPRP SysprepSession::Validate: Error in validating actions from C:\\Windows\\System32\\Sysprep\\ActionFiles\\Generalize.xml; dwRet = 0x3cf2 2024-03-02 16:05:38, Error SYSPRP RunPlatformActions:Failed while validating Sysprep session actions; dwRet = 0x3cf2 2024-03-02 16:05:38, Error [0x0f0070] SYSPRP RunDlls:An error occurred while running registry sysprep DLLs, halting sysprep execution. dwRet = 0x3cf2 2024-03-02 16:05:38, Error [0x0f00d8] SYSPRP WinMain:Hit failure while pre-validate sysprep generalize internal providers; hr = 0x80073cf2 错误分析 通过报错可以发现以下报错内容 SYSPRP Package Microsoft.LanguageExperiencePackzh-CN_22621.41.188.0_neutral__8wekyb3d8bbwe was installed for a user, but not provisioned for all users. This package will not function properly in the sysprep image. 意思是语言包无法正常封装进入系统，因为这个语言仅仅为一个用户安装了 而我们知道通过微软商城或者add-appxpackage命令安装的包都是仅仅为一个人安装了😣 问题解决 通过以下命令可以卸载一个语言包 remove-appxpackage -allusers -package &quot;Microsoft.LanguageExperiencePackzh-CN_22621.41.188.0_neutral__8wekyb3d8bbwe&quot; 然后通过DISM部署来为所有用户安装 DISM /Online /Add-ProvisionedAppxPackage /packagePath:&quot;E:\\Microsoft.LanguageExperiencePackzh-CN_22621.41.188.0_neutral__8wekyb3d8bbwe.Appx&quot; /SkipLicense 错误修正成功 ","link":"https://blog.rzly.net/post/dism_install_for_all_user/"},{"title":"VMware安装MacOS系统教程②——简易且可以直接上手的VMware打包系统","content":"本虚拟机有热衷绿野独家制作录制，不存在参考其他相似虚拟机，完全打包成功切支持vmware tool的仅此一个！如需转载，请务必通知作者！ 图片欣赏 镜像使用 全部下载所有提供的文件，使用压缩软件解压，采用分卷压缩，解压后大概30G左右！然后直接双击vmx文件即可！ 请注意！VMware必须先unlock！详细看上个教程！ 开机密码：SanHol520 镜像下载 网盘都死光了，暂不提供下载 ","link":"https://blog.rzly.net/post/vmware_macos_aio/"},{"title":"VMware安装MacOS系统教程①——VMware的安装&解锁","content":"安装准备 可以在官网下载安装安装包，然后在网上寻找激活码即可！ 下面我提供一下官网和激活码！ Download VMware Workstation Pro 10.x：https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.7-2844087.exe 12.x：https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.9-7535481.exe 14.x： Pro版：https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.8-14921873.exe Player版：https://download3.vmware.com/software/player/file/VMware-player-14.1.8-14921873.exe 15.x： Pro版：https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.7-17171714.exe Player版：https://download3.vmware.com/software/player/file/VMware-player-15.5.7-17171714.exe 16.x： Pro版：https://download3.vmware.com/software/WKST-1623-WIN-New/VMware-workstation-full-16.2.3-19376536.exe Player版：https://download3.vmware.com/software/WKST-PLAYER-1623-New/VMware-player-full-16.2.3-19376536.exe 10.x Pro版激活码：1F286-DKJD2-6Z7N1-NH1Q4-CCC3U 12.x Pro版激活码：YC7MA-45Y81-H80LP-6EYZZ-MYRY0 14.x Pro版激活码：UZ390-ADF1H-H8ENQ-HGQQT-M3HCF 15.x Pro版激活码：YA102-D7FEP-M88KQ-FYQQE-N68Y0 15.x Player版激活码：FA7DK-FRF0M-4814Q-XYYZC-QFRF2 16.x Pro版激活码：UC3XK-8DD1J-089NP-MYPXT-QGU80 16.x Player版激活码：UU1MK-8KGD7-H81XY-H5Q7Z-PCKZF 安装 直接下载安装后在最后界面 输入激活码即可，这里不多加赘述！ 解锁 为什么需要解锁VMware虚拟机？因为VMware本身不支持MacOS系统，但是内部却支持MacOS支持，只是没有放出来，所以说需要使用解锁工具！ 解锁工具下载 软件作者开源了这款工具，可以在这里下载：https://github.com/paolo-projects/unlocker/archive/master.zip 将下载的zip解压，进入解压文件夹，使用管理员命令执行win-install.cmd。 这里会自动下载一个软件包，然后自动安装。 这样，我们就完成了VMware的初始化，下一站我们就可以安装虚拟机啦~ ","link":"https://blog.rzly.net/post/vmware_unlock_macos/"},{"title":"使用Proxifier进行真全局代理并分流","content":"Proxifier 允许不支持通过代理服务器工作的网络应用程序通过 SOCKS 或 HTTPS 代理和链进行操作。 这里 是Proxifier的官网，你可以在这里下载和购买Proxifier。 激活 为了方便学习使用，我特别提供的学习使用的激活码 L6Z8A-XY2J4-BTZ3P-ZZ7DF-A2Q9C（Portable Edition） 5EZ8G-C3WL5-B56YG-SCXM9-6QZAP（Standard Edition） P427L-9Y552-5433E-8DSR3-58Z68（MAC） 配置教程 1、设置代理服务器 点击这里打开代理服务器设置 设置代理服务器 如果你有多个代理，需要设置负载均衡等，可以点击Proxy Chains，并通过Types选择负载均衡方式 2、配置代理规则 打开这里配置代理规则 例如我设置全局都走代理，只有下载、直播和本地不经过代理 注意⚠：如果你使用v2rayN等本地代理，需要将其主程序添加到直链中，否则会造成本地网络环路！ 3、设置DNS解析方式 如果你想解决DNS污染问题，可以按照以下方式配置 愉快的开始使用 现在你已经完成了配置，可以愉快地使用了~Proxifier还有很多有趣的用法，期待你的探索！ ","link":"https://blog.rzly.net/post/proxifier_proxy/"},{"title":"宝塔面板 为知笔记私有化部署+无数人空间激活方案","content":"准备 安装宝塔“docker管理器” 下载 ①至少需要安装nginx、宝塔docker管理器 ②在宝塔docker管理器添加镜像yao177/wizserver:1.0.26 安装 8805就是出口端口！ 然后点击终端，输入： cd /wiz/app/wizserver/node_modules/node-rsa/src/ rm -rf NodeRSA.js wget https://f1.rzly.net/note/NodeRSA.js --no-check-certificate 重启服务 初始化 初始账号admin@wiz.cn 初始密码123456 地址：http://你的IP:8805 为知笔记数据在宝塔/root/wizdata目录中 ","link":"https://blog.rzly.net/post/wiznote_patch/"}]}